# -*- coding: utf-8 -*-
"""exponential_smoothing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12Bo8oiTWPwIYg9tOjylx5jc8ZmBzz5ZT
"""

# ## Import Libraries

# import the relevant libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings("ignore")

# import the 3 datasets and assign them to their own variable
# import dataset
features = pd.read_csv('Features data set.csv')
sales = pd.read_csv('sales data-set.csv')
stores = pd.read_csv('stores data-set.csv')

features.sample(n=5)

sales.sample(n=5)

stores.sample(n=5)

# ## Merge the Datasets
# menyatukan dataset
# merge the 3 separate datasets using the merge function.
features = features.merge(stores, on = 'Store')
df = features.merge(sales, on = ['Store','Date','IsHoliday'])

df=df.fillna(0) #mengubah data NaN menjadi angka

df.sample(n=5)

df.shape #mengetahui jumlah dataset
#hasil ada 421570 kolom dan 16 baris

df.describe() #melihat data analisis seluruh dataset

# ## Creating an Index Based on the DATES
# membuat index berdasarkan "Date"
# sort the dataframe by date
df = df.sort_values(by='Date')

df.head(10) #melihat hasil index diurutkan berdasarkan tanggal / date

# parse the 'Day', 'Month', and 'Year' from the 'Date' column
# change the 'Date' column to the datetime format
df['Date'] = pd.to_datetime(df['Date']) #mengubah tipe data object menjadi date

df.info()

# make new columns from the day, month, and year
# menambahkan 3 kolom baru sumber nya dari kolom date
df['Day'] = df['Date'].dt.day
df['Month'] = df['Date'].dt.month
df['Year'] = df['Date'].dt.year

df.head(1)

# set the index to the date column, make sure its in the datetime format
# Pengurutan index berdasarkan date
df = df.set_index('Date')

# plot the Weekly Sales column
# plotting data berdasarkan weekly sales
df['Weekly_Sales'].plot(figsize=(25,8));

# The Weekly Sales column will be pulled out to create a new dataframe
# membuat dataset baru berdasarkan weekly sales saja
df_Sales = df[['Weekly_Sales']]

df_Sales.head(5)

# Next, we resample the dataframe to show average sales per month only, instead of every week.
# preprocessing mengubah data per hari menjadi data per bulan
df_Sales = df_Sales.resample(rule='M').mean()
df_Sales.head()

# rename the 'Weekly_Sales' column to 'Monthly_Sales'
# mengubah judul weekly menjadi monthly
df_Sales = df_Sales.rename(columns={'Weekly_Sales':'Monthly_Sales'})

df_Sales.head(5)

# plot the sales on a lineplot
# membuat plotting data
df_Sales.plot(figsize=(20,8))
plt.title('Average Monthly Sales')
plt.xlabel('Date')
plt.ylabel('Dollar Sales');

# check for nan values in the df
# mengcek apakah ada data yang kosong
df_Sales.isnull().sum()

# export the dataframe so we can use it again
# export data set menjadi file csv / excel
df.to_csv('Retail Sales Monthly.csv',index=False)

# export the dataframe so we can use it again
df.to_csv('Retail Sales Monthly.xlsx',index=False)

# lets find out how big the dataframe is. We need to figure out the size. We are going to split the data frame into training and test splits.
# cek ada berapa baris pada data terbaru
df_Sales.shape

# The size of the test set is typically about 20% of the total sample. But here, you'll see that I choose 40%. Why? Because I want to predict one year into the future AND also have a years worth of 'test' data to measure against the accuracy of the model.
# membuat data testing 40%
# In other words, does my test data match in length as far as I'm willing to forecast out?
# muliply 36 by 0.4 to find how many months to subtract to create the training data
36 * 0.4

36 - 14

# Create the Train and Test variables
# sales train variable from the begining of the dataframe to 22 months
sales_train = df_Sales.iloc[:22] #ambil seluruh baris dari awal sampai 22 tetapi 22 tidak dihitung
# sales test variable from 22 months to the end of the dataframe
sales_test = df_Sales.iloc[21:] #sisa dari data train sampai selesai

# import Expontential Smoothing
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# I'll use the additive method because the seasonal variations are roughly constant through the series
# Here, we fit the model on the training data 'sales_train'
fitted_model = ExponentialSmoothing(sales_train['Monthly_Sales'],
                                   trend = 'add',
                                   seasonal = 'add',
                                   seasonal_periods = 10).fit()

# Assign the 2 years of forecasting to the test predictions variable
# Our predictions are grabbing the fitted model, then off the fitted model object, forecast 24 months into the future
test_predictions = fitted_model.forecast(24)

# print the test_predictions
# this is a series that predicts certain values for a date
test_predictions

# ## Plot the Predictions against the Training, and Test Sets

# plot the test predictions against the past sales and test set
sales_train['Monthly_Sales'].plot(legend=True, label= 'TRAIN', figsize=(15,8))
sales_test['Monthly_Sales'].plot(legend=True, label= 'TEST', figsize=(15,8))
test_predictions.plot(legend=True, label= 'PREDICTIONS', figsize=(15,8))

plt.title('Train, Test, and Sales Predictions')
plt.xlabel("Date")
plt.ylabel("Dollar Sales");

# ## Check the Accuracy of the Model

# check the accuracy of the model
from sklearn.metrics import mean_squared_error, mean_absolute_error

# find the sales standard deviation and mean
sales_test.describe()

# change the size of the forecast
# we have to make the size of the forecast the same as the test set in order to get the squared errors
test_predictions = fitted_model.forecast(15)

# find the mean squared error
MSE = mean_squared_error(sales_test, test_predictions)
# find the mean absolute error
MAE = mean_absolute_error(sales_test, test_predictions)
# find the root mean squared error
RMSE = np.sqrt(mean_squared_error(sales_test, test_predictions))
# suppress scientific notation in the dataframe
pd.options.display.float_format = '{:.2f}'.format
# create a dataframe showing the error results
results = pd.DataFrame({'Squared Error': ['MSE','MAE','RMSE','STD DVTN'],
                       'Score': [MSE,MAE,RMSE, '1047']})
results = results.set_index('Squared Error')
results